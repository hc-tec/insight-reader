# 2.4 前端架构设计

## 1. 整体架构

### 1.1 技术选型

```json
{
  "vue": "^3.5.18",
  "nuxt": "^4.0.3",
  "shadcn-nuxt": "^2.2.0",
  "tailwindcss": "^3.4.1",
  "@vueuse/core": "^13.9.0"
}
```

### 1.2 MVP 架构特点

- **单页应用 (SPA)**: MVP 阶段无需 SSR，纯客户端渲染
- **无状态管理库**: 不使用 Pinia，用 Composition API 管理状态
- **极简路由**: 只有一个主页面
- **组件化**: 高度模块化的组件设计

---

## 2. 目录结构

```
frontend/
├── app/
│   ├── components/
│   │   ├── ui/                          # Shadcn UI 组件
│   │   │   ├── button/
│   │   │   ├── card/
│   │   │   ├── input/
│   │   │   ├── textarea/
│   │   │   ├── popover/
│   │   │   └── scroll-area/
│   │   │
│   │   ├── ArticleInput.vue             # 文章输入区
│   │   ├── ReaderLayout.vue             # 双栏布局
│   │   ├── ArticlePane.vue              # 左侧文章面板
│   │   ├── InsightPane.vue              # 右侧洞察面板
│   │   ├── TextSelector.vue             # 划词选中组件
│   │   ├── IntentButtons.vue            # 智能预测按钮
│   │   ├── InsightCard.vue              # 洞察卡片
│   │   └── AppHeader.vue                # 页面头部
│   │
│   ├── composables/
│   │   ├── useArticle.ts                # 文章状态管理
│   │   ├── useSelection.ts              # 划词选中逻辑
│   │   ├── useInsightGenerator.ts       # 洞察生成
│   │   └── useSSE.ts                    # SSE 流式响应
│   │
│   ├── pages/
│   │   └── index.vue                    # 唯一页面
│   │
│   ├── utils/
│   │   ├── api.ts                       # API 调用封装
│   │   ├── textParser.ts                # 文本处理
│   │   └── constants.ts                 # 常量定义
│   │
│   ├── types/
│   │   ├── article.ts                   # 文章类型
│   │   ├── insight.ts                   # 洞察类型
│   │   └── selection.ts                 # 选中类型
│   │
│   └── assets/
│       └── css/
│           └── main.css                 # 全局样式
│
├── public/
│   └── favicon.ico
│
├── nuxt.config.ts                       # Nuxt 配置
├── tailwind.config.js                   # Tailwind 配置
├── package.json
└── README.md
```

---

## 3. 核心 Composables

### 3.1 文章状态管理 (useArticle.ts)

```typescript
// composables/useArticle.ts
import { ref, computed } from 'vue'
import type { Article, Sentence } from '~/types/article'
import { splitIntoSentences } from '~/utils/textParser'

export const useArticle = () => {
  const content = ref('')
  const title = ref('')
  const sentences = ref<Sentence[]>([])
  const isReading = ref(false)

  const hasContent = computed(() => content.value.trim().length > 0)
  const sentenceCount = computed(() => sentences.value.length)

  const setArticle = (articleContent: string, articleTitle?: string) => {
    content.value = articleContent
    title.value = articleTitle || extractTitle(articleContent)

    // 句子分割
    sentences.value = splitIntoSentences(articleContent)
    isReading.value = true
  }

  const clearArticle = () => {
    content.value = ''
    title.value = ''
    sentences.value = []
    isReading.value = false
  }

  const extractTitle = (text: string): string => {
    // 取前50个字符作为标题
    const firstLine = text.split('\n')[0]
    return firstLine.substring(0, 50) + (firstLine.length > 50 ? '...' : '')
  }

  return {
    content,
    title,
    sentences,
    isReading,
    hasContent,
    sentenceCount,
    setArticle,
    clearArticle
  }
}
```

### 3.2 划词选中逻辑 (useSelection.ts)

```typescript
// composables/useSelection.ts
import { ref, computed } from 'vue'
import { useTextSelection } from '@vueuse/core'
import type { Selection } from '~/types/selection'

export const useSelection = () => {
  const { text, rects } = useTextSelection()
  const selectedText = ref('')
  const context = ref('')
  const position = ref({ x: 0, y: 0 })
  const showIntentButtons = ref(false)

  // 防抖选中文本
  const debouncedText = refDebounced(text, 200)

  watch(debouncedText, (newText) => {
    if (newText && newText.trim().length > 0) {
      selectedText.value = newText.trim()
      extractContext(newText)
      updatePosition()
      showIntentButtons.value = true
    } else {
      clear()
    }
  })

  const extractContext = (selected: string) => {
    // 从文章中找到选中文本的位置
    const article = useArticle()
    const content = article.content.value

    const startIndex = content.indexOf(selected)
    if (startIndex === -1) return

    // 提取前后各200字符作为上下文
    const contextStart = Math.max(0, startIndex - 200)
    const contextEnd = Math.min(content.length, startIndex + selected.length + 200)

    context.value = content.substring(contextStart, contextEnd)
  }

  const updatePosition = () => {
    if (rects.value && rects.value.length > 0) {
      const lastRect = rects.value[rects.value.length - 1]
      position.value = {
        x: lastRect.left + lastRect.width / 2,
        y: lastRect.bottom + 10
      }
    }
  }

  const clear = () => {
    selectedText.value = ''
    context.value = ''
    showIntentButtons.value = false
  }

  // 意图识别（简单规则）
  const suggestedIntent = computed(() => {
    const len = selectedText.value.length
    if (len < 5) return 'explain'  // 短文本倾向于解释
    if (len > 50) return 'analyze'  // 长文本倾向于分析
    if (/因为|所以|由于|导致/.test(selectedText.value)) return 'analyze'
    return 'explain'
  })

  return {
    selectedText,
    context,
    position,
    showIntentButtons,
    suggestedIntent,
    clear
  }
}
```

### 3.3 洞察生成 (useInsightGenerator.ts)

```typescript
// composables/useInsightGenerator.ts
import { ref } from 'vue'
import type { InsightRequest, InsightResponse } from '~/types/insight'

export const useInsightGenerator = () => {
  const isGenerating = ref(false)
  const currentInsight = ref('')
  const error = ref<string | null>(null)

  const generate = async (request: InsightRequest) => {
    isGenerating.value = true
    currentInsight.value = ''
    error.value = null

    try {
      const { useSSE } = await import('~/composables/useSSE')
      const { connect } = useSSE()

      await connect('/api/v1/insights/generate', request, {
        onStart: () => {
          currentInsight.value = ''
        },
        onDelta: (content: string) => {
          currentInsight.value += content
        },
        onComplete: (metadata) => {
          isGenerating.value = false
          console.log('洞察生成完成', metadata)
        },
        onError: (err) => {
          error.value = err.message
          isGenerating.value = false
        }
      })
    } catch (err) {
      error.value = '网络错误，请重试'
      isGenerating.value = false
    }
  }

  const clear = () => {
    currentInsight.value = ''
    error.value = null
    isGenerating.value = false
  }

  return {
    isGenerating,
    currentInsight,
    error,
    generate,
    clear
  }
}
```

### 3.4 SSE 流式响应 (useSSE.ts)

```typescript
// composables/useSSE.ts
import type { InsightRequest } from '~/types/insight'

interface SSECallbacks {
  onStart?: () => void
  onDelta?: (content: string) => void
  onComplete?: (metadata: any) => void
  onError?: (error: any) => void
}

export const useSSE = () => {
  const connect = async (
    url: string,
    data: InsightRequest,
    callbacks: SSECallbacks
  ) => {
    const config = useRuntimeConfig()
    const fullUrl = `${config.public.apiBase}${url}`

    const response = await fetch(fullUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data)
    })

    if (!response.ok) {
      throw new Error('请求失败')
    }

    const reader = response.body?.getReader()
    const decoder = new TextDecoder()

    if (!reader) {
      throw new Error('无法读取响应流')
    }

    try {
      while (true) {
        const { done, value } = await reader.read()
        if (done) break

        const chunk = decoder.decode(value)
        const lines = chunk.split('\n')

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const jsonStr = line.substring(6)
            try {
              const event = JSON.parse(jsonStr)

              switch (event.type) {
                case 'start':
                  callbacks.onStart?.()
                  break
                case 'delta':
                  callbacks.onDelta?.(event.content)
                  break
                case 'complete':
                  callbacks.onComplete?.(event.metadata)
                  break
                case 'error':
                  callbacks.onError?.(event)
                  break
              }
            } catch (e) {
              console.error('解析 SSE 事件失败', e)
            }
          }
        }
      }
    } finally {
      reader.releaseLock()
    }
  }

  return {
    connect
  }
}
```

---

## 4. 核心组件设计

### 4.1 主页面 (pages/index.vue)

```vue
<template>
  <div class="min-h-screen bg-gray-50">
    <AppHeader />

    <!-- 未开始阅读：显示输入界面 -->
    <ArticleInput
      v-if="!isReading"
      @submit="handleArticleSubmit"
    />

    <!-- 阅读界面：双栏布局 -->
    <ReaderLayout v-else>
      <template #left>
        <ArticlePane :content="content" :sentences="sentences" />
      </template>

      <template #right>
        <InsightPane
          :insight="currentInsight"
          :is-loading="isGenerating"
        />
      </template>
    </ReaderLayout>

    <!-- 划词弹出框 -->
    <IntentButtons
      v-if="showIntentButtons"
      :position="position"
      :selected-text="selectedText"
      :suggested-intent="suggestedIntent"
      @select="handleIntentSelect"
      @close="clearSelection"
    />
  </div>
</template>

<script setup lang="ts">
const {
  content,
  sentences,
  isReading,
  setArticle
} = useArticle()

const {
  selectedText,
  context,
  position,
  showIntentButtons,
  suggestedIntent,
  clear: clearSelection
} = useSelection()

const {
  currentInsight,
  isGenerating,
  generate
} = useInsightGenerator()

const handleArticleSubmit = (articleContent: string) => {
  setArticle(articleContent)
}

const handleIntentSelect = async (intent: string) => {
  await generate({
    selected_text: selectedText.value,
    context: context.value,
    intent
  })
  clearSelection()
}
</script>
```

### 4.2 文章输入组件 (ArticleInput.vue)

```vue
<template>
  <div class="container mx-auto px-4 py-12">
    <div class="max-w-3xl mx-auto">
      <h1 class="text-4xl font-bold text-center mb-2">
        InsightReader
      </h1>
      <p class="text-center text-gray-600 mb-8">
        划词即问，即刻理解
      </p>

      <Card>
        <CardContent class="pt-6">
          <Textarea
            v-model="content"
            placeholder="粘贴文章内容..."
            class="min-h-[400px] text-base"
          />

          <div class="flex justify-between items-center mt-4">
            <span class="text-sm text-gray-500">
              {{ charCount }} 字符
            </span>

            <Button
              @click="handleSubmit"
              :disabled="!canSubmit"
              size="lg"
            >
              开始阅读
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, computed } from 'vue'

const emit = defineEmits<{
  submit: [content: string]
}>()

const content = ref('')

const charCount = computed(() => content.value.length)
const canSubmit = computed(() => content.value.trim().length >= 50)

const handleSubmit = () => {
  if (canSubmit.value) {
    emit('submit', content.value)
  }
}
</script>
```

### 4.3 双栏布局 (ReaderLayout.vue)

```vue
<template>
  <div class="flex h-[calc(100vh-64px)]">
    <!-- 左侧：文章面板 -->
    <div class="flex-1 overflow-auto border-r">
      <slot name="left" />
    </div>

    <!-- 右侧：洞察面板 -->
    <div class="w-[500px] overflow-auto bg-white">
      <slot name="right" />
    </div>
  </div>
</template>

<style scoped>
/* 自定义滚动条 */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}
</style>
```

### 4.4 文章面板 (ArticlePane.vue)

```vue
<template>
  <div class="max-w-4xl mx-auto px-8 py-12">
    <article class="prose prose-lg">
      <div
        v-html="formattedContent"
        @mouseup="handleMouseUp"
      />
    </article>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'

const props = defineProps<{
  content: string
}>()

// 简单的 Markdown 渲染（或使用 marked 库）
const formattedContent = computed(() => {
  return props.content
    .split('\n')
    .map(line => `<p>${line}</p>`)
    .join('')
})

const handleMouseUp = () => {
  // 选中文本的逻辑由 useSelection 自动处理
}
</script>
```

### 4.5 智能预测按钮 (IntentButtons.vue)

```vue
<template>
  <Popover v-model:open="isOpen">
    <PopoverTrigger as-child>
      <div
        :style="{
          position: 'fixed',
          left: `${position.x}px`,
          top: `${position.y}px`
        }"
      />
    </PopoverTrigger>

    <PopoverContent class="w-80">
      <div class="space-y-2">
        <p class="text-sm font-medium mb-3">
          "{selectedText.substring(0, 30)}..."
        </p>

        <Button
          variant="outline"
          class="w-full justify-start"
          @click="() => handleSelect('explain')"
        >
          <Icon name="lucide:help-circle" class="mr-2" />
          这是什么意思？
        </Button>

        <Button
          variant="outline"
          class="w-full justify-start"
          @click="() => handleSelect('analyze')"
        >
          <Icon name="lucide:brain" class="mr-2" />
          作者为什么这么说？
        </Button>

        <!-- V2.0: 反方观点 -->
        <!-- <Button variant="outline" @click="...">
          有不同的看法吗？
        </Button> -->
      </div>
    </PopoverContent>
  </Popover>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const props = defineProps<{
  position: { x: number; y: number }
  selectedText: string
  suggestedIntent: string
}>()

const emit = defineEmits<{
  select: [intent: string]
  close: []
}>()

const isOpen = ref(true)

const handleSelect = (intent: string) => {
  emit('select', intent)
  isOpen.value = false
}
</script>
```

### 4.6 洞察卡片 (InsightCard.vue)

```vue
<template>
  <div class="p-6">
    <div v-if="isLoading" class="flex items-center gap-2">
      <Icon name="lucide:loader-2" class="animate-spin" />
      <span class="text-sm text-gray-500">AI 思考中...</span>
    </div>

    <Card v-else-if="insight" class="border-none shadow-none">
      <CardContent class="pt-6">
        <div class="prose prose-sm" v-html="renderedInsight" />
      </CardContent>
    </Card>

    <div v-else class="text-center text-gray-400 mt-20">
      <Icon name="lucide:lightbulb" class="w-12 h-12 mx-auto mb-4" />
      <p>选中文本，提出问题</p>
      <p class="text-sm mt-2">AI 会帮你深度理解</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue'
import { marked } from 'marked'

const props = defineProps<{
  insight: string
  isLoading: boolean
}>()

const renderedInsight = computed(() => {
  return marked(props.insight)
})
</script>
```

---

## 5. 工具函数

### 5.1 文本处理 (utils/textParser.ts)

```typescript
export interface Sentence {
  id: number
  text: string
  start: number
  end: number
}

export function splitIntoSentences(text: string): Sentence[] {
  // 简单的句子分割（MVP版本）
  const sentenceRegex = /[^.!?。！？]+[.!?。！？]+/g
  const matches = text.match(sentenceRegex) || []

  let currentPos = 0
  return matches.map((text, index) => {
    const start = currentPos
    const end = start + text.length
    currentPos = end

    return {
      id: index,
      text: text.trim(),
      start,
      end
    }
  })
}
```

### 5.2 API 调用 (utils/api.ts)

```typescript
export const api = {
  async generateInsight(request: InsightRequest) {
    const config = useRuntimeConfig()
    const response = await fetch(`${config.public.apiBase}/api/v1/insights/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(request)
    })

    if (!response.ok) {
      throw new Error('API 调用失败')
    }

    return response
  }
}
```

---

## 6. Nuxt 配置

```typescript
// nuxt.config.ts
export default defineNuxtConfig({
  compatibilityDate: '2024-01-01',

  modules: [
    '@nuxtjs/tailwindcss',
    'shadcn-nuxt'
  ],

  shadcn: {
    prefix: '',
    componentDir: './app/components/ui'
  },

  runtimeConfig: {
    public: {
      apiBase: process.env.NUXT_PUBLIC_API_BASE || 'http://localhost:8000'
    }
  },

  // SPA 模式（MVP）
  ssr: false,

  app: {
    head: {
      title: 'InsightReader - 划词即问，即刻理解',
      meta: [
        { charset: 'utf-8' },
        { name: 'viewport', content: 'width=device-width, initial-scale=1' },
        { name: 'description', content: '最好的阅读辅助工具' }
      ]
    }
  }
})
```

---

## 7. 性能优化

### 7.1 虚拟滚动（长文章）

```vue
<!-- 仅在文章超长时启用 -->
<template>
  <VirtualScroller
    v-if="sentences.length > 500"
    :items="sentences"
    :item-height="60"
  >
    <template #default="{ item }">
      <p>{{ item.text }}</p>
    </template>
  </VirtualScroller>

  <div v-else>
    <p v-for="sentence in sentences" :key="sentence.id">
      {{ sentence.text }}
    </p>
  </div>
</template>
```

### 7.2 流式渲染优化

```typescript
// 使用 requestAnimationFrame 批量更新
let pendingChunks: string[] = []
let rafPending = false

function appendChunk(chunk: string) {
  pendingChunks.push(chunk)

  if (!rafPending) {
    rafPending = true
    requestAnimationFrame(() => {
      currentInsight.value += pendingChunks.join('')
      pendingChunks = []
      rafPending = false
    })
  }
}
```

---

**文档版本**: 2.0（基于最新产品蓝图）
**最后更新**: 2025-01-19
