# 个人认知仪表盘 - 功能说明

## 🎯 功能概述

**个人认知仪表盘** 是 InsightReader 的核心可视化功能,通过分析用户的阅读行为和火花点击记录,构建个性化的知识图谱,帮助用户:

- 📊 **可视化知识资产**: 将抽象的知识概念转化为直观的图谱
- 🧭 **发现思维模式**: 识别你的好奇心特征和阅读偏好
- 🔍 **探索认知盲区**: 发现未涉足的知识领域和孤立的概念

## ✨ 核心功能

### 1. 知识图谱 (Knowledge Graph)

#### 功能说明
使用 D3.js 力导向图可视化用户的知识网络,每个节点代表一个概念或实体,节点之间的连线表示概念的关联关系。

#### 视觉特性
- **节点大小**: 反映点击频次,越大表示越重要
- **节点颜色**: 根据知识领域自动分配
  - 🟢 绿色 (Emerald): 人工智能
  - 🟣 紫色 (Violet): 哲学
  - 🟡 黄色 (Amber): 经济学
  - ⚫ 灰色 (Slate): 未分类
- **连线粗细**: 反映关系强度,越粗表示关联越紧密

#### 交互功能
- **缩放**: 鼠标滚轮缩放视图 (0.1x - 4x)
- **平移**: 拖拽画布平移
- **节点拖拽**: 拖动节点重新排列布局
- **节点详情**: 点击节点查看详细信息
- **重置视图**: 一键恢复初始视角
- **暂停/继续**: 控制物理模拟动画

#### 构建逻辑
```
用户点击火花 → 提取概念/实体 → 创建节点
同一文章中的概念 → 建立关联 → 创建边
概念频次统计 → 决定节点大小
关键词匹配 → 识别领域 → 分配颜色
```

#### 使用示例
```
场景: 用户阅读了3篇关于机器学习的文章,点击了以下火花:
- "深度学习" (5次)
- "神经网络" (3次)
- "反向传播" (2次)
- "卷积网络" (2次)

结果: 生成4个节点,所有节点标记为"人工智能"领域(绿色),
     "深度学习"节点最大,与其他3个节点都有连接
```

---

### 2. 好奇心指纹 (Curiosity Fingerprint)

#### 功能说明
分析用户最近30天的火花点击数据,生成多维度的好奇心特征画像。

#### 分析维度

**a) 主导类型洞察**
识别用户最关注的火花类型:
- **概念型 (Concept)**: 喜欢抽象概念,理论思维强
- **论证型 (Argument)**: 关注逻辑推理,批判性思维强
- **实体型 (Entity)**: 偏好具体事物,实践导向

**b) 火花类型分布**
统计三种类型的占比,显示为进度条,直观展示兴趣侧重。

**c) 时间序列分析**
展示最近7天的点击趋势,帮助用户了解阅读活跃度变化。

**d) 话题云**
提取高频词汇,词语大小反映出现频次,形成个性化话题图谱。

#### 使用示例
```
场景: 用户在过去30天内点击了100个火花:
- 概念型: 45个 (45%)
- 论证型: 30个 (30%)
- 实体型: 25个 (25%)

主导类型: 概念型
话题云: ["深度学习"(16), "神经网络"(12), "AI"(10), ...]
时间趋势: 周末点击量明显高于工作日
```

#### 自我认知价值
- **学习风格识别**: 理论派 vs 实践派
- **兴趣分布**: 是否过于集中或过于分散
- **阅读节奏**: 持续学习 vs 间歇学习

---

### 3. 思维盲区探测 (Blind Spot Detection)

#### 功能说明
通过分析知识图谱结构,发现两类认知盲区:

**a) 缺失领域 (Missing Domains)**
预定义8个主流知识领域:
- 人工智能 🤖
- 经济学 💰
- 哲学 🧠
- 计算机科学 💻
- 生物学 🧬
- 物理学 ⚛️
- 历史 📚
- 心理学 🧘

显示用户尚未涉足的领域,鼓励跨领域学习。

**b) 知识孤岛 (Knowledge Islands)**
使用图论算法 (DFS) 检测孤立的概念集合,例如:
```
孤岛1: [深度学习, 神经网络, 反向传播]
孤岛2: [市场经济, 供需关系]

问题: 两个孤岛之间没有任何连接
建议: 阅读"AI在经济预测中的应用"等跨领域内容建立桥梁
```

#### 推荐逻辑
为每个孤岛生成具体的阅读建议,引导用户建立概念之间的联系。

#### 使用示例
```
场景: 用户的知识图谱包含以下节点:
- AI领域: 深度学习、神经网络 (相互连接)
- 经济学领域: 市场经济、供需关系 (相互连接)
- 但AI和经济学之间没有连接

检测结果:
✅ 缺失领域: 生物学、物理学、历史
⚠️ 知识孤岛: 2个独立集群

建议:
- 探索生物学领域的科普文章
- 阅读"AI+经济学"交叉内容,打通孤岛
```

---

## 🎨 设计理念

### 视觉风格
遵循"深邃、冥想"的设计哲学:

**色彩系统**
- 主色: Emerald (#10b981) → Teal (#14b8a6) 渐变
- 辅助色: Slate (#64748b) → Zinc (#71717a) 渐变
- 强调色: Amber (#f59e0b) → Orange (#f97316) 渐变

**玻璃态美学 (Glassmorphism)**
- 半透明白色背景 (`bg-white/70`)
- 背景模糊效果 (`backdrop-blur-xl`)
- 柔和边框 (`border-gray-200/50`)
- 大圆角 (`rounded-2xl`)

**光影层次**
- 背景装饰: 大尺寸模糊光球 (`blur-3xl`)
- 卡片阴影: 多层次阴影系统 (`shadow-sm/md/lg`)
- 渐变效果: 文字、图标、按钮均使用渐变

**动画设计**
- 悬停效果: 缩放 + 阴影增强
- 过渡动画: 200ms ease-out
- 加载状态: 脉冲动画 (`animate-pulse`)
- D3.js 物理模拟: 流畅的节点运动

### 交互体验
- **非侵入式**: 所有操作都是可选的,不强制用户交互
- **即时反馈**: 每次操作都有视觉或动画反馈
- **渐进披露**: 先展示概览,点击查看详情
- **容错设计**: 空状态、加载状态、错误状态均有友好提示

---

## 🚀 快速开始

### 访问仪表盘
1. 登录 InsightReader
2. 点击顶部导航栏的 **"仪表盘"** 按钮
3. 或访问 `/dashboard` 路由

### 生成数据
仪表盘数据来自你的阅读行为:
1. 阅读文章时点击火花 (带下划线的关键词)
2. 系统自动记录点击并分析
3. 实时更新知识图谱和好奇心指纹

### 首次使用
如果是新用户,仪表盘会显示空状态:
```
暂无知识图谱数据
开始点击火花,构建你的知识网络
```

建议至少点击 10-20 个火花后再查看仪表盘,以获得更有意义的分析结果。

---

## 📊 数据更新机制

### 自动更新
- **火花点击**: 立即记录,实时更新好奇心指纹
- **知识图谱**: 增量更新,点击新概念时自动添加节点

### 手动更新
- **重建图谱**: 点击知识图谱卡片右上角的"重建图谱"按钮
  - 用途: 数据修复、算法升级后重新分析
  - 耗时: 通常 1-3 秒
  - 影响: 删除旧数据,完全重建

### 缓存策略
- 好奇心指纹计算结果缓存在数据库
- 每次火花点击后自动刷新缓存
- 减少重复计算,提升加载速度

---

## 💡 最佳实践

### 如何建立高质量知识图谱?

**1. 持续阅读**
- 保持每周至少 3-5 次的阅读频率
- 每次点击 5-10 个火花

**2. 多样化内容**
- 阅读不同领域的文章
- 避免过度集中在单一主题

**3. 跨领域学习**
- 关注领域交叉的内容 (如 "AI + 经济学")
- 主动建立概念之间的联系

**4. 定期回顾**
- 每周查看一次仪表盘
- 观察知识图谱的增长变化
- 根据盲区检测结果调整阅读方向

### 如何解读好奇心指纹?

**主导类型分析**
- **概念型主导 (>50%)**: 理论思维强,适合学术研究
  - 建议: 增加实践类内容,平衡理论与应用
- **论证型主导 (>50%)**: 批判性思维强,逻辑严密
  - 建议: 补充概念性知识,夯实理论基础
- **实体型主导 (>50%)**: 实践导向,关注具体应用
  - 建议: 阅读理论文章,提升抽象思维

**时间序列分析**
- **持续上升**: 学习动力强,保持节奏
- **波动剧烈**: 学习不规律,建议制定计划
- **长期低谷**: 可能需要调整学习策略或休息

### 如何应对思维盲区?

**缺失领域**
- 选择1-2个感兴趣的领域
- 从科普类文章开始
- 逐步建立基础概念网络

**知识孤岛**
- 阅读跨领域综述文章
- 寻找概念之间的隐含联系
- 主动思考不同领域的相似性

---

## 🔧 常见问题

### Q1: 为什么我的知识图谱是空的?
**A**: 需要先点击火花。建议阅读2-3篇文章,点击10个以上火花后再查看。

### Q2: 节点颜色是如何确定的?
**A**: 根据概念的知识领域自动分配:
- 绿色: 人工智能
- 紫色: 哲学
- 黄色: 经济学
- 灰色: 未分类

### Q3: 如何让知识图谱更清晰?
**A**:
- 拖拽节点重新排列
- 缩放调整视图比例
- 暂停物理模拟,手动整理布局
- 点击"重置视图"恢复默认

### Q4: 重建图谱会丢失数据吗?
**A**: 不会。重建只是重新分析已有的火花点击记录,不会删除原始数据。

### Q5: 好奇心指纹多久更新一次?
**A**: 每次点击火花后立即更新,但只分析最近30天的数据。

### Q6: 为什么我没有盲区?
**A**:
- 可能你已经涉足了多个领域 (恭喜!)
- 或者点击的火花数量还不够 (建议 >30 个)

### Q7: 知识孤岛是坏事吗?
**A**: 不一定。少量孤岛是正常的,但如果大部分概念都孤立,可能需要:
- 阅读更多综合性内容
- 主动思考概念之间的联系
- 探索跨领域文章

### Q8: 可以导出知识图谱吗?
**A**: 当前版本暂不支持,未来计划支持导出为 PNG/SVG 图片。

---

## 🔬 技术原理

### 知识图谱构建算法

**节点提取**
```python
# 从火花点击中提取概念
for click in spark_clicks:
    if click.spark_type == "concept":
        node = create_node(
            label=click.spark_text,
            size=click_count,
            domain=identify_domain(click.spark_text)
        )
```

**关系推断 (共现分析)**
```python
# 同一文章中出现的概念建立关联
article_concepts = {}
for click in clicks:
    article_concepts[click.article_id].add(click.concept)

for concepts in article_concepts.values():
    for concept_a in concepts:
        for concept_b in concepts:
            if concept_a != concept_b:
                create_edge(concept_a, concept_b, weight=0.5)
```

**领域识别 (关键词匹配)**
```python
domain_keywords = {
    "人工智能": ["深度学习", "AI", "神经网络"],
    "经济学": ["市场", "供需", "通货膨胀"],
    # ...
}

for domain, keywords in domain_keywords.items():
    if any(keyword in concept for keyword in keywords):
        return domain
```

### D3.js 力导向布局

**物理模拟**
```javascript
d3.forceSimulation(nodes)
  .force('link', d3.forceLink(edges)
    .distance(100)    // 边长
    .strength(0.5)    // 弹簧强度
  )
  .force('charge', d3.forceManyBody()
    .strength(-300)   // 节点互斥力
  )
  .force('center', d3.forceCenter(width/2, height/2))
  .force('collision', d3.forceCollide()
    .radius(d => d.size * 3 + 10)  // 防碰撞半径
  )
```

**更新循环**
```javascript
simulation.on('tick', () => {
  // 每帧更新节点和边的位置
  nodes.attr('transform', d => `translate(${d.x},${d.y})`)
  edges.attr('x1', d => d.source.x)
       .attr('y1', d => d.source.y)
       .attr('x2', d => d.target.x)
       .attr('y2', d => d.target.y)
})
```

### 孤岛检测算法 (DFS)

```python
def find_connected_components(nodes, edges):
    # 构建邻接表
    adjacency = defaultdict(set)
    for edge in edges:
        adjacency[edge.source].add(edge.target)
        adjacency[edge.target].add(edge.source)

    visited = set()
    islands = []

    def dfs(node, component):
        visited.add(node)
        component.add(node)
        for neighbor in adjacency[node]:
            if neighbor not in visited:
                dfs(neighbor, component)

    # 遍历所有节点,找出连通分量
    for node in nodes:
        if node not in visited:
            component = set()
            dfs(node, component)
            if len(component) >= 2:  # 至少2个节点才算孤岛
                islands.append(component)

    return islands
```

---

## 📚 相关文档

- [技术设计文档](./personal-cognitive-dashboard.md)
- [实施总结](./dashboard-implementation-summary.md)
- [API 参考](./dashboard-api-reference.md)
- [实施清单](./dashboard-checklist.md)

---

## 🙏 反馈与建议

如果你在使用过程中遇到问题或有改进建议,欢迎通过以下方式反馈:
- 提交 GitHub Issue
- 联系开发团队
- 参与用户调研

---

**文档版本**: 1.0.0
**最后更新**: 2025-10-20
**维护者**: InsightReader Team
